---
layout: post
title: JS 强制类型转换
---
## ～运算符
~ 按位非(注意位运算只适用于32位整数)，先讲操作数强制转换为32位整数，通过抽象操作ToInt32实现，ToInt32首先执行ToNumber强制类型转换（比如“123“会先转换为123，然后再执行ToInt32）

### ~x 大致等同于 -(x+1)
```
~42; // -(42 + 1) ==> -43
~-1; // -(-1 + 1) ==> 0
```
~x中唯一能得到0的是当x为-1时，所以可以用于真/假值转换
```
var a = 'Hello World';

if (a.indexOf("lo") >= 0) {//true

}

if (a.indexOf("ol") == -1) {// true

}
```
>=0 和 == -1这样的写法不是很好，称为“抽象滲漏”，意思是在代码中暴露了底层实现细节，这里指-1作为失败时的返回值，应该被屏蔽。
```
if (~a.indexOf('lo')) { // true

}

if (!~a.indexOf('lo')) { // false

}
```
### ~~字位截取
有时可以使用~~x来截取x的整数部分，和Math.floor()类似，但是并不是完全一样。

~~第一个~对x进行ToInt32并反转字位，第二个再进行一次反转为原值，这样就转换为整数了，不过对于负数会和Math.floor返回不一样的结果
```
Math.floor(-49.6); // -50
~49.6; //-49
```
x | 0也可以达到一样的效果

### ｜运算 执行ToInt32转换

```
0 | -0;       //0
0 | NaN;      //0
0 | Infinity; //0
0 | -Infinity;//0
```
以上这些特殊数字无法以32位格式呈现，因此ToInt32返回0

## 显示解析数字字符串 parseInt
```
var a = '42';
var b = '42px';

Number(a); // 42
parseInt(a); //42

Number(b); // NaN
parseInt(b); //42
```
解析允许字符串中出现非数字字符，解析从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。

parseInt,parseFloat是解析，所以参数可以出现非数字字符。需要注意的是，它们接受的参数是字符串，如果传递其他类型参数，首先会被强制转换为字符串，我们应该尽量避免传递非字符串参数，否则容易出问题。
```
parseInt(1/0, 19); // 18
```
因为1/0是Infinity，parseInt会先把参数转换为字符串，那么以上操作相当于是parseInt("Infinity", 19),第一个字符是“I”，以19为基数时为18，第二个“n”不是有效的数字字符，所以解析结束，最后结果是18。

以下还有其他奇怪的例子，也可以解释通：
```
parseInt(0.000008); // 0 (parseInt("0.000008"))
parseInt(0.0000008); // 8 (parseInt("8e-7")) 小数点后超过5个连续的0的小数转换为字符串时会转换为科学计数法
parseInt(false, 16); // 250 ('fa' parseInt('false'))
```

